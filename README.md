# Домашнее задание к занятию "`Резервное копирование баз даных`" - `Татаринцев Алексей`



---

### Задание 1

`Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования.`

1. `Необходимо восстанавливать данные в полном объёме за предыдущий день.`
```
Для таких целей подойдет полное резервное копирование (Full Backup) ежедневно.
- Преимущества: Простота восстановления. Легко реализовать.
- Недостатки: Самое долгое время резервного копирования. Требует больше места для хранения.

```
2. `Восстановление данных за час до предполагаемой поломки`
```
Комбинация полного, инкрементного или дифференциального резервного копирования .
- Полное резервное копирование (Full Backup): Как в п. 1.1, выполняется регулярно.
- Дифференциальное резервное копирование (Differential Backup): Ежедневно, но копируются только изменения с момента последнего полного резервного копирования. Это быстрее, чем полное, но медленнее, чем инкрементное.
- Инкрементное резервное копирование (Incremental Backup): Ежедневно, но копируются только изменения с момента последнего любого (полного или инкрементного) резервного копирования. Самое быстрое резервное копирование, но самое сложное и долгое восстановление, так как для восстановления нужно последовательно применить все инкрементные копии с момента последнего полного резервного копирования.
 
```
3. `Моментальное переключение на работающую или починенную базу данных`

```
Использование кластеризации баз данных, репликации и/или технологии Always On Availability Groups (в случае использования MS SQL Server).
- Кластеризация баз данных (Database Clustering): Несколько серверов баз данных работают вместе как единая система. В случае сбоя одного сервера, другой сервер автоматически берет на себя его роль.
- Репликация (Replication): Данные с основной базы данных (primary) постоянно реплицируются (копируются) на резервную базу данных (replica). В случае сбоя основной базы данных, резервная база данных автоматически становится основной. Существуют различные типы репликации: синхронная (данные записываются одновременно на обе базы, обеспечивает минимальную потерю данных, но может замедлять работу) и асинхронная (данные сначала записываются на основную
базу, а потом реплицируются, более быстрая, но возможна потеря данных).
- Always On Availability Groups (MS SQL Server): Аналогично репликации, но предоставляет более гибкие настройки и возможности для переключения между базами данных.
```
---

### Задание 2

`PostgreSQL`

1. `С помощью официальной документации приведите пример команды резервирования данных и восстановления БД (pgdump/pgrestore).`
```
pg_dump -U <имя_пользователя> -h <имя_хоста> -p <порт> -F p -f <имя_файла_резервной_копии.sql> <имя_базы_данных>

*   -U <имя_пользователя>: Имя пользователя PostgreSQL, под которым будет выполняться операция. Часто это postgres.
•   -h <имя_хоста>: Имя хоста, где находится сервер PostgreSQL.  Используйте localhost или 127.0.0.1 для локального сервера.
•   -p <порт>: Номер порта PostgreSQL. По умолчанию 5432.
•   -F p:  Указывает формат вывода. p означает plain text (обычный SQL-скрипт).  Другие варианты включают c (custom format), d (directory format), t (tar format). Формат c предпочтительнее для больших баз данных, т.к. поддерживает сжатие и параллельное восстановление.
•   -f <имя_файла_резервной_копии.sql>: Имя файла, в который будет записана резервная копия.
•   <имя_базы_данных>: Имя базы данных, которую нужно скопировать.

Пример:
pg_dump -U postgres -h localhost -p 5432 -F p -f my_database_backup.sql my_database

Эта команда создаст файл my_database_backup.sql с SQL-инструкциями, необходимыми для восстановления базы данных my_database.

Восстановление (pg_restore):
psql -U <имя_пользователя> -h <имя_хоста> -p <порт> -d <имя_базы_данных> -f <имя_файла_резервной_копии.sql>
*   -U <имя_пользователя>: Имя пользователя PostgreSQL.
•   -h <имя_хоста>: Имя хоста.
•   -p <порт>: Номер порта.
•   -d <имя_базы_данных>: Имя базы данных, в которую нужно восстановить данные.  База данных должна существовать!
•   -f <имя_файла_резервной_копии.sql>: Имя файла резервной копии.

Пример:
psql -U postgres -h localhost -p 5432 -d my_database -f my_database_backup.sql
```
2. `Возможно ли автоматизировать этот процесс? Если да, то как?`
```
Да, процесс резервного копирования можно автоматизировать.  Есть несколько способов:

1.  Cron:  Cron - это планировщик задач, доступный в большинстве Unix-подобных операционных систем. Может использовать cron для запуска команд pg_dump через определенные промежутки времени (например, каждый день в 2 часа ночи).

    Пример записи в crontab (отредактируйте с помощью команды crontab -e):
 0 2   * pg_dump -U postgres -h localhost -p 5432 -F c -f /path/to/backups/my_database_$(date +\%Y-\%m-\%d).dump my_database
Эта запись будет запускать pg_dump каждый день в 2:00 ночи и сохранять резервную копию в файл с именем my_database_<дата>.dump в каталоге /path/to/backups/. Обратите внимание на экранирование символа % в date +\%Y-\%m-\%d.
2 . Скрипты Shell:  Можем создать скрипт shell, который выполняет резервное копирование и, например, ротацию старых резервных копий.  Затем этот скрипт можно запустить через cron.  Это обеспечивает большую гибкость и контроль над процессом.
3.  Инструменты управления резервным копированием:  Существуют специализированные инструменты, такие как Barman, pgBackRest, и другие, которые предоставляют более продвинутые возможности управления резервными копиями, включая инкрементальное резервное копирование, WAL archiving и point-in-time recovery (PITR). Они требуют более сложной настройки, но обеспечивают более надежное и гибкое решение для резервного копирования.
```

---

### Задание 3

`MySQL`

1. `С помощью официальной документации приведите пример команды инкрементного резервного копирования базы данных MySQL.`
```
MySQL Enterprise Backup - один из рекомендуемых инструментов для создания инкрементных резервных копий, особенно в производственных средах. Однако, для демонстрации принципа инкрементного резервного копирования можно использовать и mysqldump, хотя это и менее эффективно для больших и активно изменяющихся баз данных.

Вот пример, демонстрирующий концепцию с mysqldump:

Предпосылки:

•  У нас есть база данных mydatabase.
•  Мы хотим создать полную резервную копию, а затем инкрементные копии, сохраняющие только изменения.

Шаги:
1. Полная резервная копия:
    mysqldump -u root -p --all-databases --flush-logs --master-data=2 > full_backup.sql

*  -u root -p: Учетные данные для подключения к MySQL. Замените root на вашего пользователя, и у нас будет запрошен пароль.
  •  --all-databases: Дампит все базы данных (если нужно дампить только одну, укажите её имя).
  •  --flush-logs: Очищает бинарные логи после создания резервной копии (важно для последующих инкрементных резервных копий). ВНИМАНИЕ: Рассмотрите влияние этой опции на вашу стратегию восстановления. Если вы храните бинарные логи отдельно, можно её опустить.
  •  --master-data=2: Добавляет в дамп информацию о позиции в бинарном логе на момент создания дампа. Эта информация необходима для восстановления из инкрементных копий.
  •  > full_backup.sql: Перенаправляет вывод mysqldump в файл full_backup.sql.

2. Инкрементная резервная копия (пример):

  Чтобы создать инкрементную резервную копию, нужно найти последнюю позицию в бинарном логе из предыдущей полной (или предыдущей инкрементной) резервной копии. Эту информацию можно найти в full_backup.sql. Найдите строку, похожую на:
    -- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=123456;
 Теперь используйем эту информацию для создания инкрементной копии:
     mysqlbinlog --start-position=123456 mysql-bin.000001 > incremental_backup_1.sql
*  mysqlbinlog: Утилита для извлечения данных из бинарных логов.
  •  --start-position=123456: Указывает начальную позицию в бинарном логе, с которой нужно извлекать изменения. Замените 123456 на значение, найденное в full_backup.sql.
  •  mysql-bin.000001: Имя файла бинарного лога, который нужно обработать. Замените mysql-bin.000001 на имя, найденное в full_backup.sql.
  •  > incremental_backup_1.sql: Перенаправляет вывод в файл incremental_backup_1.sql.

Восстановление из инкрементных резервных копий:
1. Восстановите полную резервную копию:
    mysql -u root -p < full_backup.sql
2. Восстановите инкрементные резервные копии по порядку:
    mysql -u root -p < incremental_backup_1.sql
    mysql -u root -p < incremental_backup_2.sql
    ...

   
```
2. `Преимущества реплики по сравнению с обычным резервным копированием`
```
Использование реплики вместо или в дополнение к обычному резервному копированию может дать следующие преимущества:

- Сокращение времени простоя при восстановлении: Если основная база данных выходит из строя, реплика может быть быстро переведена в режим основной базы данных. Это значительно быстрее, чем восстановление из резервной копии, особенно если база данных большая.

-Высокая доступность: Репликация обеспечивает высокую доступность, так как в случае сбоя основной базы данных, приложение может быть переключено на реплику.

-Возможность чтения данных с реплики: Реплики можно использовать для обработки запросов на чтение, что позволяет разгрузить основную базу данных и повысить производительность. Это особенно полезно для отчетов и аналитики.

-Возможность тестирования изменений без риска для основной БД: Изменения схемы, обновления приложения и другие операции можно протестировать на реплике, прежде чем применять их к основной базе данных. Это снижает риск возникновения проблем в производственной среде.

-Географическое распределение: Реплики можно размещать в разных географических регионах, что обеспечивает защиту от региональных сбоев и снижает задержку для пользователей, находящихся в разных частях мира.

-Создание резервных копий без влияния на основную БД: Резервные копии можно создавать с реплики, что позволяет избежать нагрузки на основную базу данных во время создания резервной копии.
```
